#include <iostream>
#include <string>

#include <fstream>
#include <Windows.h>
#include <gdiplus.h>
#include <thread>

#include <opencv2/core/core.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/imgproc/imgproc.hpp>

#pragma comment(lib, "gdiplus.lib")

using namespace std;
using namespace Gdiplus;
using namespace cv;
#define IsMatching(page,isClick) IsMatchingWith( (page),(isClick),#page)

// JPEG formatının CLSID'sini almak için yardımcı işlev
int GetEncoderClsid(const WCHAR* format, CLSID* pClsid)
{
	UINT num = 0;          // encoder sayısı
	UINT size = 0;         // boyut gereksinimi

	ImageCodecInfo* pImageCodecInfo = nullptr;

	GetImageEncodersSize(&num, &size);
	if (size == 0)
		return -1;  // Başarısız

	pImageCodecInfo = (ImageCodecInfo*)(malloc(size));
	if (pImageCodecInfo == nullptr)
		return -1;  // Başarısız

	GetImageEncoders(num, size, pImageCodecInfo);

	for (UINT j = 0; j < num; ++j)
	{
		if (wcscmp(pImageCodecInfo[j].MimeType, format) == 0)
		{
			*pClsid = pImageCodecInfo[j].Clsid;
			free(pImageCodecInfo);
			return j;  // Başarılı
		}
	}

	free(pImageCodecInfo);
	return -1;  // Başarısız

}
void SaveScreenshotToFile(const wchar_t* filename)
{

	// Ekranın boyutunu al
	int screenX = GetSystemMetrics(SM_XVIRTUALSCREEN);
	int screenY = GetSystemMetrics(SM_YVIRTUALSCREEN);
	int screenWidth = GetSystemMetrics(SM_CXVIRTUALSCREEN);
	int screenHeight = GetSystemMetrics(SM_CYVIRTUALSCREEN);

	// Ekran görüntüsü için bir bitmap oluştur
	HDC screenDC = GetDC(nullptr);
	HDC memDC = CreateCompatibleDC(screenDC);
	HBITMAP hBitmap = CreateCompatibleBitmap(screenDC, screenWidth, screenHeight);
	HBITMAP hOldBitmap = (HBITMAP)SelectObject(memDC, hBitmap);

	// Ekranı kopyala
	BitBlt(memDC, 0, 0, screenWidth, screenHeight, screenDC, screenX, screenY, SRCCOPY);

	// GDI+ bitmap oluştur
	Bitmap screenshotBitmap(hBitmap, nullptr);

	// Dosyaya kaydet
	CLSID clsid;
	GetEncoderClsid(L"image/jpeg", &clsid);  // Kaydedilecek dosya formatını belirtin

	screenshotBitmap.Save(filename, &clsid, nullptr);

	// Bellek temizleme
	SelectObject(memDC, hOldBitmap);
	DeleteObject(hBitmap);
	DeleteDC(memDC);
	ReleaseDC(nullptr, screenDC);

}
Mat challengesPage, adsStartButton, attackButton, nextButton;
Mat X_Close_1, X_Close_2, X_Close_3, X_Close_4, X_Close_5, X_Close_6, X_Close_7, X_Close_8, X_Close_9, X_Close_10;
Mat lastPage;

void setLastPage() {
	lastPage = imread("screenShots//screenshot.jpg", IMREAD_COLOR);
}

bool True = true;
const wchar_t* filename = L"screenShots//screenshot.jpg";
void clickScreen(int x, int y) {
	// Fareyi (x, y) koordinatlarına taşıma
	SetCursorPos(x, y);

	// Sol fare düğmesini basma ve bırakma işlemi yapma
	mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0); // Sol düğmeyi basma
	waitKey(350);
	mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);   // Sol düğmeyi bırakma
	cout << "tıklandı X:" << x << " Y:" << y << endl;

}
void ClickStartAds() {
	clickScreen(1010, 830);
}
void ClickStartAttack() {
	clickScreen(1041, 906);
}
void ClickNextButton() {
	clickScreen(1036, 718);
}
bool IsMatchingWith(Mat page, bool isClick, string name) {

	Mat cloneMat = lastPage.clone();
	// İkinci resmin boyutunu al
	int width = page.cols;
	int height = page.rows;

	// İlk resim üzerinde eşleşme yapmak için template eşleme işlemini uygula
	Mat result;
	matchTemplate(cloneMat, page, result, TM_CCOEFF_NORMED);

	vector<cv::Point> matchLocations;
	// Eşleşmelerin konumunu bul
	double minVal, maxVal;
	cv::Point minLoc, maxLoc;
	minMaxLoc(result, &minVal, &maxVal, &minLoc, &maxLoc);
	/*imshow("Sonuç", page);
	waitKey(15000);*/
	// Eşleşme noktasını çerçevele
	cv::Point topLeft(maxLoc.x, maxLoc.y);
	cv::Point bottomRight(maxLoc.x + width, maxLoc.y + height);
	rectangle(cloneMat, topLeft, bottomRight, Scalar(0, 255, 0), 2);
	//rectangle(result, maxLoc, cv::Point(maxLoc.x + width, maxLoc.y + height), Scalar(0), FILLED);

	// İkinci resmin içinde mi kontrol et
	if (maxVal >= 0.8)
	{
		cout << name << " : maxVal : " << maxVal << "====================> ESLESME BASARILI." << endl;

		if (isClick)
		{
			int centerX = maxLoc.x + width / 2;
			int centerY = maxLoc.y + height / 2;
			clickScreen(centerX, centerY);
		}

		return true;
	}
	else
	{
		cout << name << " : maxVal : " << maxVal << "=======> BULUNAMADI." << endl;
		/*	imshow(name, cloneMat);*/
	}

	/* imshow("Sonuç", lastPage);
	 waitKey(0);*/

	return false;
}

bool AssignConstantMat() {

	challengesPage = imread("pages//Chalanges.png", IMREAD_COLOR);
	if (challengesPage.empty())
	{
		cout << "chanlagersPage yüklenemedi." << endl;
		return false;
	}

	adsStartButton = imread("buttons//AdsStartButton.png", IMREAD_COLOR);
	if (adsStartButton.empty())
	{
		cout << "AdsStartButton yüklenemedi." << endl;
		return false;
	}

	attackButton = imread("buttons//AttackButton.png", IMREAD_COLOR);
	if (attackButton.empty())
	{
		cout << "attackButton yüklenemedi." << endl;
		return false;
	}

	nextButton = imread("buttons//NextButton.png", IMREAD_COLOR);
	if (nextButton.empty())
	{
		cout << "nextButton yüklenemedi." << endl;
		return false;
	}

	X_Close_1 = imread("signs//X_Close_1.png", IMREAD_COLOR);
	if (X_Close_1.empty())
	{
		cout << "X_Close_1 yüklenemedi." << endl;
		return false;
	}

	X_Close_2 = imread("signs//X_Close_2.png", IMREAD_COLOR);
	if (X_Close_2.empty())
	{
		cout << "X_Close_2 yüklenemedi." << endl;
		return false;
	}

	X_Close_3 = imread("signs//X_Close_3.png", IMREAD_COLOR);
	if (X_Close_3.empty())
	{
		cout << "X_Close_3 yüklenemedi." << endl;
		return false;
	}

	X_Close_4 = imread("signs//X_Close_4.png", IMREAD_COLOR);
	if (X_Close_4.empty())
	{
		cout << "X_Close_4 yüklenemedi." << endl;
		return false;
	}

	X_Close_5 = imread("signs//X_Close_5.png", IMREAD_COLOR);
	if (X_Close_5.empty())
	{
		cout << "X_Close_5 yüklenemedi." << endl;
		return false;
	}


	X_Close_6 = imread("signs//X_Close_6.png", IMREAD_COLOR);
	if (X_Close_6.empty())
	{
		cout << "X_Close_6 yüklenemedi." << endl;
		return false;
	}

	X_Close_7 = imread("signs//X_Close_7.png", IMREAD_COLOR);
	if (X_Close_7.empty())
	{
		cout << "X_Close_7 yüklenemedi." << endl;
		return false;
	}

	X_Close_8 = imread("signs//X_Close_8.png", IMREAD_COLOR);
	if (X_Close_8.empty())
	{
		cout << "X_Close_8 yüklenemedi." << endl;
		return false;
	}

	X_Close_9 = imread("signs//X_Close_9.png", IMREAD_COLOR);
	if (X_Close_9.empty())
	{
		cout << "X_Close_9 yüklenemedi." << endl;
		return false;
	}

	X_Close_10 = imread("signs//X_Close_10.png", IMREAD_COLOR);
	if (X_Close_10.empty())
	{
		cout << "X_Close_10 yüklenemedi." << endl;
		return false;
	}

	return true;
}

void RemoveAdsArea(Mat& adsImg) {

	cv::Rect roiUp(0, 0, adsImg.cols, 85);
	rectangle(adsImg, roiUp, Scalar(0), FILLED);

	cv::Rect roiDown(0, 190, adsImg.cols, adsImg.rows);
	rectangle(adsImg, roiDown, Scalar(0), FILLED);

}
bool hasCloseButton() {
	if (IsMatching(X_Close_1, true) ||
		IsMatching(X_Close_2, true) ||
		IsMatching(X_Close_3, true) ||
		IsMatching(X_Close_4, true) ||
		IsMatching(X_Close_5, true) ||
		IsMatching(X_Close_6, true) ||
		IsMatching(X_Close_7, true) ||
		IsMatching(X_Close_8, true) ||
		IsMatching(X_Close_8, true) ||
		IsMatching(X_Close_10, true))
	{
		return true;
	}

	return false;
}
void CloseAds() {

	waitKey(30000);
	int limit = 4;
	int counter = 0;

	while (counter < limit) {
		cout << "Ads has been Waiting";
		waitKey(2000);

		SaveScreenshotToFile(filename);
		setLastPage();
		RemoveAdsArea(lastPage);
		/*	imshow("Sonuç", lastPage);
			waitKey(0);*/
		if (hasCloseButton())
		{
			break;
		}
		counter++;
	}


	if (counter >= limit)
	{
		throw invalid_argument("CloseAds ERROR");
	}
}

void StartTheWar() {
	cout << "StartTheWar..." << endl;

	int counter = 0;
	int limit = 3;

	while (counter < limit)
	{
		SaveScreenshotToFile(filename);
		setLastPage();

		if (IsMatching(attackButton, false)) {
		
			ClickStartAttack();
			break;
		}

		cout << "War is waiting..." << endl;
		waitKey(2000);

		counter++;
	}

	if (counter >= limit)
	{
		if (hasCloseButton())
		{
			StartTheWar();
			return;
		}
		throw invalid_argument("StartTheWar ERROR");
	}
}

void ClickForNext(bool isControl = false) {
	cout << "ClickForNext..." << endl;

	int counter = 0;
	int limit = 15;
	waitKey(4000);

	while (counter < limit)
	{
		SaveScreenshotToFile(filename);
		setLastPage();

		if (IsMatching(nextButton, false))
		{
			waitKey(2000);

			ClickNextButton();
			break;
		}

		cout << "Next button is waiting... Counter: " << counter << endl;
		waitKey(2000);

		counter++;
	}

	if (counter >= limit)
	{
		throw invalid_argument("ClickForNext ERROR");
	}
}

void test() {
	AssignConstantMat();
	while (true)
	{
		setLastPage();
		RemoveAdsArea(lastPage);

		if (IsMatching(X_Close_5, false))
		{

			cout << "BULDU" << endl;
		}
		waitKey(0);

	}

}
int main()
{
	//test();
	// GDI+ başlatılıyor
	GdiplusStartupInput gdiplusStartupInput;
	ULONG_PTR gdiplusToken;
	GdiplusStartup(&gdiplusToken, &gdiplusStartupInput, nullptr);

	if (!AssignConstantMat())
		return 0;

	//namedWindow("challenges", WINDOW_AUTOSIZE);
	//imshow("attackButton", attackButton);
	waitKey(5000);
	int errorCounter = 0;
	try
	{
		while (true)
		{
			SaveScreenshotToFile(filename);
			cout << "Ekran goruntusu dosyaya kaydedildi: " << filename << endl;

			setLastPage();

			if (IsMatching(challengesPage, false)) {
				ClickStartAds();
				CloseAds();
				StartTheWar();
				ClickForNext();
			}
			else
			{
				throw invalid_argument("Baslangic sayfasi hatali");
			}
			waitKey(2000);
		}
	}
	catch (const std::exception& e)
	{

		SaveScreenshotToFile(L"errorScreens//errorshot.jpg");
		cout << "ERROR => Ekran görüntüsü dosyaya kaydedildi: " << filename << endl;

		cerr << "EXCEPTION: " << e.what() << endl;

	}


	// GDI+ kapat
	GdiplusShutdown(gdiplusToken);

	return 0;
}
